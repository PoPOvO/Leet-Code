# 问题描述

>来源:leetCode.592

给定一个表示分数加法和减法表达式的字符串，需要以字符串格式返回计算结果。最终的结果应该是不可简化的部分。如果你的最终结果是一个整数，例如2，你需要将它改为分母1的分数的格式。所以在这种情况下，2应该被转换为2/1。

例1：
输入： “-1/2+1/2”
输出：“0/1”

例2：
输入： “-1/2+1/2+1/3”
输出：“1/3”

例3：
输入： “1/3-1/2”
输出：“-1/6”

例4：
输入： “5/3+1/3”
输出：“2/1”

注意：
输入字符串只包含'0'到'9'，'/'，'+'和'-'。输出也是如此。
每个分数（输入和输出）都具有格式±分子/分母。如果第一个输入分数或输出是正数，那么'+'将被忽略。
输入只包含有效不可分的分数，每个分数的分子和分母总是在[1,10]的范围内。如果分母是1，则表示这个分数实际上是一个以上定义的分数格式的整数。
给定分数的数量将在[1,10]范围内。
最终结果的分子和分母保证有效且在32位整数范围内。

# 解决方案

根据人类求分式加法的方式可以将算法分为三大步。

* 对分式通分，即**求所有分式分母的最小公倍数。**
* 根据通分的结果对分子进行变形，即对(分子*(最小公倍数/分母))，并且对所有的分子求和
* 对结果分式化简，即对分子和分母**同除于它们的最大公约数**

但实际程序计算中没有必要求所有分母的最小公倍数，这样耗时太长。可以直接使用 **a/b + c/d = (ad + bc)/ bd**的方式计算。

详细步骤：
1. 对输入结果扫描，根据"+/-"对字符进行分割，但是不能丢失分式的"+/-"号，因此我的处理方式是先对字符串的"+"和"-"进行"+:"和"-:"替换，再根据":"分割字符串到数组`items`
2. 对数组`items`循环，根据`a/b + c/d = (ad + bc)/ bd`来计算所有的分子和与分母和。
4. 对计算结果`分子/分母`进行化简，即求出其最大公约数并由分子除以分母。

# 大神解法

大神在字符序列的扫描上用了一个很巧妙的Java方法。

```
Scanner sc = new Scanner(expression).useDelimiter("/|(?=[-+])");
```
这个方法类似于`split()`，它将以给定的正则来分割字符串并放入Scanner对象。这句正则利用了**正向肯定预查**，分别匹配`/`和`+、-`前面的空白。从而将字符串分割为数字序列。
